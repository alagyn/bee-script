%include <memory>
%include <syntax-node.h>

%return std::shared_ptr<SyntaxNode>

# Line comments
%ignore "#[^\n]*\n"

# Starting rule
program = top_level_defs;

# Terminals
SEMICOLON = ";";
OPEN_CURLY = "\{";
CLOSE_CURLY = "\}";
OPEN_PAREN = "\(";
CLOSE_PAREN = "\)";
OPEN_SQUARE = '\[';
CLOSE_SQUARE = "\]";
COMMA = ",";
COLON = ":";
ARROW = "->";

KW_IF = "if";
KW_ELIF = "elif";
KW_ELSE = "else";
KW_DEF = "def";
KW_FOR = "for";
KW_RETURN = "return";

KW_OR = "or";
KW_AND = "and";
KW_NOT = "not";

OP_ASSIGN = "=";
OP_EQU = "==";
OP_NEQ = "!=";
OP_LT = "<";
OP_GT = ">";
OP_LTEQ = "<=";
OP_GTEQ = ">=";
OP_MINUS = "-";
OP_PLUS = "\+";
OP_STAR = "\*";
OP_SLASH = "/";
OP_MOD = "%";
OP_POW = "\*\*";

TYPE_INT = "int";
TYPE_BOOL = "bool";
TYPE_STR = "str";

LIT_INT = "-?\d+";
LIT_STR = '"([^"]|(\"))*"';
LIT_BOOL_FALSE = "false";
LIT_BOOL_TRUE = "true";

lit_bool 
    = LIT_BOOL_FALSE
    {
        auto out = std::make_shared<ExprNode>();
        out->type = ExprType::LitBool;
        out->intValue = 0;
        return out;
    }
    | LIT_BOOL_TRUE
    {
        auto out = std::make_shared<ExprNode>();
        out->type = ExprType::LitBool;
        out->intValue = 1;
        return out;
    }
    ;

# This goes after all the builtins
NAME = "[\l\u][\l\u\d_]*";

top_level_defs
    = top_level_def
    | top_level_def top_level_defs
    {
        $0->next = $1;
        return $0;
    }
    ;

top_level_def
    = func_def
    | var_def
    ;

func_def = KW_DEF NAME OPEN_PAREN arg_def_list CLOSE_PAREN ARROW type block
    {
        auto out = std::make_shared<DeclNode>();

        out->name = $NAME;

        auto funcType = std::make_shared<TypeNode>();
        funcType->type = Type::Func;
        funcType->subtype = std::static_pointer_cast<TypeNode>($type);
        funcType->args = std::static_pointer_cast<ArgList>($arg_def_list);

        out->type = funcType;
        out->code = std::static_pointer_cast<StmtNode>($block);

        return out;
    }
    ;

arg_def_list
    = arg_def arg_def_list
    {
        $arg_def->next = $arg_def_list;
        return $arg_def;
    }
    | EMPTY
    {
        return nullptr;
    }
    ;

arg_def = NAME COLON type
    {
        auto out = std::make_shared<ArgList>();
        out->type = std::static_pointer_cast<TypeNode>($type);
        out->name = $NAME;
        return out;
    }
    ;

var_def = NAME COLON type OP_ASSIGN expr SEMICOLON
    {
        auto out = std::make_shared<DeclNode>();
        out->name = $NAME;
        out->type = std::static_pointer_cast<TypeNode>($type);
        out->value = std::static_pointer_cast<ExprNode>($expr);
        return out;
    }
    | NAME COLON type SEMICOLON
    {
        auto out = std::make_shared<DeclNode>();
        out->name = $NAME;
        out->type = std::static_pointer_cast<TypeNode>($type);
        return out;
    }
    ;

type 
    = type_name OPEN_SQUARE LIT_INT CLOSE_SQUARE
    {
        auto out = std::make_shared<TypeNode>();
        out->type = Type::Array;
        out->subtype = std::static_pointer_cast<TypeNode>($type_name);
        return out;
    }
    | type_name
    ;

type_name
    = TYPE_INT
    {
        auto out = std::make_shared<TypeNode>();
        out->type = Type::Int;
        return out;
    }
    | TYPE_STR
    {
        auto out = std::make_shared<TypeNode>();
        out->type = Type::Str;
        return out;
    }
    | TYPE_BOOL
    {
        auto out = std::make_shared<TypeNode>();
        out->type = Type::Bool;
        return out;
    }
    ;


block = OPEN_CURLY stmt_list CLOSE_CURLY
    {
        return $stmt_list;
    }
    ;

stmt_list
    = stmt
    | stmt stmt_list
    {
        $stmt->next = $stmt_list;
        return $stmt;
    }
    ;

stmt
    = var_def
    | if_clause elif_clauses
    {
        auto out = std::static_pointer_cast<StmtNode>($if_clause);
        out->elseBody = std::static_pointer_cast<StmtNode>($elif_clauses);
        return out;
    }
    | expr
    ;

if_clause
    = KW_IF OPEN_PAREN expr CLOSE_PAREN block
    {
        auto out = std::make_shared<StmtNode>();
        out->kind = StmtType::IfElse;
        out->expr = std::static_pointer_cast<ExprNode>($expr);
        out->body = std::static_pointer_cast<StmtNode>($block);
        return out;
    }
    ;

elif_clauses 
    = elif_clause elif_clauses
    {
        auto out = std::static_pointer_cast<StmtNode>($elif_clause);
        out->elseBody = std::static_pointer_cast<StmtNode>($elif_clauses);
        return out;
    }
    | elif_clause
    | else_clause
    ;

elif_clause 
    = KW_ELIF OPEN_PAREN expr CLOSE_PAREN block
    {
        auto out = std::make_shared<StmtNode>();
        out->kind = StmtType::IfElse;
        out->expr = std::static_pointer_cast<ExprNode>($expr);
        out->body = std::static_pointer_cast<StmtNode>($block);
        return out;
    }
    ;

else_clause 
    = KW_ELSE block
    {
        return $block;
    }
    | EMPTY
    {
        return nullptr;
    }
    ;

expr = 
    expr KW_OR logical_and_expr { return std::make_shared<ExprNode>(ExprType::LogAnd, $0, $2); }
    | logical_and_expr
    ;

logical_and_expr = logical_and_expr KW_AND equality_expr { return std::make_shared<ExprNode>(ExprType::LogAnd, $0, $2);}
    | equality_expr
    ;

equality_expr 
    = equality_expr OP_EQU compare_expr { return std::make_shared<ExprNode>(ExprType::LogEqu, $0, $2);}
    | equality_expr OP_NEQ compare_expr { return std::make_shared<ExprNode>(ExprType::LogNeq, $0, $2);}
    | compare_expr
    ;

compare_expr
    = compare_expr OP_LT math_expr { return std::make_shared<ExprNode>(ExprType::CmpLT, $0, $2);}
    | compare_expr OP_LTEQ math_expr { return std::make_shared<ExprNode>(ExprType::CmpLTEQ, $0, $2);}
    | compare_expr OP_GT math_expr { return std::make_shared<ExprNode>(ExprType::CmpGT, $0, $2);}
    | compare_expr OP_GTEQ math_expr { return std::make_shared<ExprNode>(ExprType::CmpGTEQ, $0, $2);}
    | math_expr
    ;

math_expr
    = math_expr OP_PLUS term { return std::make_shared<ExprNode>(ExprType::Add, $0, $2);}
    | math_expr OP_MINUS term { return std::make_shared<ExprNode>(ExprType::Sub, $0, $2);}
    | term
    ;

term
    = term OP_STAR factor { return std::make_shared<ExprNode>(ExprType::Mul, $0, $2);}
    | term OP_SLASH factor { return std::make_shared<ExprNode>(ExprType::Div, $0, $2);}
    | term OP_MOD factor { return std::make_shared<ExprNode>(ExprType::Mod, $0, $2);}
    | factor
    ;

factor
    = factor OP_POW pow_term { return std::make_shared<ExprNode>(ExprType::Pow, $0, $2);}
    | pow_term
    ;

pow_term
    = KW_NOT func_or_sub { return std::make_shared<ExprNode>(ExprType::LogNot, $1, nullptr);}
    | OP_MINUS func_or_sub { return std::make_shared<ExprNode>(ExprType::Neg, $1, nullptr);}
    | func_or_sub
    ;

func_or_sub
    = bottom_val OPEN_PAREN arg_call_list CLOSE_PAREN
    {
        auto out = std::make_shared<ExprNode>();
        out->type = ExprType::Call;
        
        out->left = $bottom_val;
        out->right = std::static_pointer_cast<ExprNode>($arg_call_list);

        return out;
    }
    | bottom_val OPEN_SQUARE expr CLOSE_SQUARE { return std::make_shared<ExprNode>(ExprType::Subscript, $bottom_val, $expr); }
    ;

bottom_val
    = NAME
    {
        auto out = std::make_shared<ExprNode>();
        out->type = ExprType::Name;
        out->name = $0;
        return out;
    }
    | LIT_INT
    {
        auto out = std::make_shared<ExprNode>();
        out->type = ExprType::LitInt;
        out->intValue = std::stoi($0);
        return out;
    }
    | LIT_STR
    {
        auto out = std::make_shared<ExprNode>();
        out->type = ExprType::LitInt;
        out->strValue = $0; // TODO strip quotes
        return out;
    }
    | OPEN_PAREN expr CLOSE_PAREN { return $expr; }
    | lit_bool
    ;

arg_call_list
    = expr COMMA arg_call_list
    {
        auto out = std::static_pointer_cast<ExprNode>($expr);
        out->right = std::static_pointer_cast<ExprNode>($arg_call_list);
        return out;
    }
    | expr
    ;